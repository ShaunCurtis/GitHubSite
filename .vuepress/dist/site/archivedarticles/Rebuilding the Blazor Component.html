<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Building a new Blazor Base Component</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.b25df986.css" as="style"><link rel="preload" href="/assets/js/app.de94086e.js" as="script"><link rel="preload" href="/assets/js/2.0005fb99.js" as="script"><link rel="preload" href="/assets/js/22.8c84fb58.js" as="script"><link rel="prefetch" href="/assets/js/10.1b1bac62.js"><link rel="prefetch" href="/assets/js/11.d5ccb284.js"><link rel="prefetch" href="/assets/js/12.041ebee5.js"><link rel="prefetch" href="/assets/js/13.32117bf8.js"><link rel="prefetch" href="/assets/js/14.846c76b5.js"><link rel="prefetch" href="/assets/js/15.50f29b11.js"><link rel="prefetch" href="/assets/js/16.1209f32e.js"><link rel="prefetch" href="/assets/js/17.05965361.js"><link rel="prefetch" href="/assets/js/18.0deb6c5a.js"><link rel="prefetch" href="/assets/js/19.c0b807a9.js"><link rel="prefetch" href="/assets/js/20.eca6b9de.js"><link rel="prefetch" href="/assets/js/21.83db0212.js"><link rel="prefetch" href="/assets/js/23.e8ce4875.js"><link rel="prefetch" href="/assets/js/24.fd7b0084.js"><link rel="prefetch" href="/assets/js/25.cdf82bd3.js"><link rel="prefetch" href="/assets/js/26.f554011d.js"><link rel="prefetch" href="/assets/js/27.df20cf08.js"><link rel="prefetch" href="/assets/js/28.2318a9ac.js"><link rel="prefetch" href="/assets/js/29.628dd84b.js"><link rel="prefetch" href="/assets/js/3.1a98c051.js"><link rel="prefetch" href="/assets/js/30.47ff2eac.js"><link rel="prefetch" href="/assets/js/31.eb71eabe.js"><link rel="prefetch" href="/assets/js/32.c74d3c6a.js"><link rel="prefetch" href="/assets/js/33.19a01216.js"><link rel="prefetch" href="/assets/js/34.aed43787.js"><link rel="prefetch" href="/assets/js/35.b40f612a.js"><link rel="prefetch" href="/assets/js/36.ae14410d.js"><link rel="prefetch" href="/assets/js/37.74d7c586.js"><link rel="prefetch" href="/assets/js/38.54528dd5.js"><link rel="prefetch" href="/assets/js/39.e8c514e8.js"><link rel="prefetch" href="/assets/js/4.3083dbc5.js"><link rel="prefetch" href="/assets/js/40.5c97b972.js"><link rel="prefetch" href="/assets/js/41.7a1cf8ba.js"><link rel="prefetch" href="/assets/js/42.f449294e.js"><link rel="prefetch" href="/assets/js/43.432c7e84.js"><link rel="prefetch" href="/assets/js/44.d56e3403.js"><link rel="prefetch" href="/assets/js/45.c6081de4.js"><link rel="prefetch" href="/assets/js/5.28112fa8.js"><link rel="prefetch" href="/assets/js/6.50910651.js"><link rel="prefetch" href="/assets/js/7.90248bbe.js"><link rel="prefetch" href="/assets/js/8.d8750b3a.js"><link rel="prefetch" href="/assets/js/9.ab982ebf.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b25df986.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="building-a-new-blazor-base-component"><a href="#building-a-new-blazor-base-component" class="header-anchor">#</a> Building a new Blazor Base Component</h1> <p><em>ComponentBase</em> is the out-of-the-box base component for Blazor.  This article picks on it, highlighting some deficiencies, and describes how to build an alternative.</p> <p>The Blazor UI is built by a renderer which holds a tree structure of classes implementing <em>IComponent</em> - commonly called the RenderTree.  The only requirement for a component to be added to the render tree is it implements <em>IComponent</em>.  The  renderer communicates with components in the tree through <em>IComponent</em> interface methods.</p> <p><em>ComponentBase</em> is the out-of-the-box <em>IComponent</em> implementation shipped with Blazor.  You don't have to use <em>ComponentBase</em>, just build components implementing <em>IComponent</em>.</p> <h2 id="why-change"><a href="#why-change" class="header-anchor">#</a> Why Change</h2> <p>This may be personal, but I have a few issues with <em>ComponentBase</em>:</p> <ol><li>The nomenclature is misleading: it leads to a lot of misconceptions about what's happening.  When I started using Blazor for real, I had to look at the <em>ComponentBase</em> code to get my head around what was really going on. Some examples:
<ul><li><em>OnInitialized</em> sounds like it gets run when the class is initialised, maybe replacing new. Misconception: it has nothing to do with class initialization.</li> <li><em>StateHasChanged</em> sounds like a boolean property, which it certainly isn't.</li></ul></li> <li>The sequencing of first render and subsequent render isn't logical.  Using <em>OnInitializedAsync</em> for the first rendering sort of works, but <em>OnParametersSetAsync</em> for the first and any subsequent rendering doesn't.  It just isn't intiutive.</li> <li>I want my applications to implement &quot;Async all the Way&quot;, no non-async methods for bottling out.</li></ol> <h2 id="component"><a href="#component" class="header-anchor">#</a> Component</h2> <p>The full class code is <a href="https://github.com/ShaunCurtis/CEC.Blazor/blob/Experimental/CEC.Blazor/Components/Base/Component.cs" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> on GitHub in CEC.Blazor/Components/Base on the Experimental Branch.</p> <p>Please note that a significant amount of the code base is the same as <em>ComponentBase</em> - don't re-invent the wheel!</p> <p>The class is abstract so can't be used directly.  In addition to <em>IComponent</em>, it implements <em>IHandleEvent</em> and <em>IHandleAfterRender</em> for Render Event notification by the Renderer.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">IComponent</span><span class="token punctuation">,</span> <span class="token class-name">IHandleEvent</span><span class="token punctuation">,</span> <span class="token class-name">IHandleAfterRender</span></span>
</code></pre></div><h3 id="properties"><a href="#properties" class="header-anchor">#</a> Properties</h3> <p>The full property list is shown below.  The same as <em>ComponentBase</em> with <em>Loading</em> added.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token comment">/// Property to check if the component is loading -  set internally</span>
<span class="token comment">/// I use this in UI components with significant lag to show a &quot;working&quot; rotator when Loading is in process</span>
<span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> Loading <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">protected</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token comment">/// Holds the render fragment for the component - called by the Renderer whenever a queued render event is executed.</span>
<span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">RenderFragment</span> _renderFragment<span class="token punctuation">;</span>
<span class="token comment">/// Holds the RenderHandle for the Renderer, passed to the component in when the Render calls Attach.</span>
<span class="token keyword">private</span> <span class="token class-name">RenderHandle</span> _renderHandle<span class="token punctuation">;</span>
<span class="token comment">/// Boolean set during Attach or Reset</span>
<span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">bool</span></span> _firstRender <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token comment">/// Boolean set once the component has rendered for the first time</span>
<span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">bool</span></span> _hasNeverRendered <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token comment">// Boolean set when a render event is queued but not yet executed.</span>
<span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">bool</span></span> _hasPendingQueuedRender<span class="token punctuation">;</span>
<span class="token comment">// Boolean used for internal control of After Render process</span>
<span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">bool</span></span> _hasCalledOnAfterRender<span class="token punctuation">;</span>
</code></pre></div><h3 id="methods"><a href="#methods" class="header-anchor">#</a> Methods</h3> <p>The public methods we want to implement are:</p> <ol><li><em>OnRenderAsync(bool firstRender)</em> - this replaces <em>OnInitializedAsync</em> and <em>OnParametersSetAsync</em>.  <em>firstRender</em> is only set true when the component is rendered for the first time (as part of the <em>Attach</em> process).  A virtual method, normally overridden.</li> <li><em>Render()</em> - this replaces <em>StateHasChanged</em>.  It kicks off a render of the component.  It's not declared virtual so can't be overridden.</li> <li><em>OnAfterRenderAsync(bool firstRender)</em> - the same as <em>ComponentBase</em>.  It's called after the component has rendered.   A virtual method, normally overridden.</li> <li><em>ResetAsync()</em> - a method to manually re-render the component for the first time with the current parameters.</li></ol> <p>The component initialization method is straight from <em>ComponentBase</em>.  It builds the component render fragment.  To be clear we're building the render fragment here, using the builder to load code into the render fragment.  We not executing it.  A <em>RenderFragment</em> is a block of code run by the Renderer to render the component.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    _renderFragment <span class="token operator">=</span> builder <span class="token operator">=&gt;</span>
    <span class="token punctuation">{</span>
        _hasPendingQueuedRender <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        _hasNeverRendered <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token function">BuildRenderTree</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><em>SetParametersAsync</em> is defined by <em>IComponent</em>.  It's called by the Renderer when any of the component's registered parameters or cascaded parameters are changed externally.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">SetParametersAsync</span><span class="token punctuation">(</span><span class="token class-name">ParameterView</span> parameters<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/// Applies the supplied parameters to the component's properties.</span>
    parameters<span class="token punctuation">.</span><span class="token function">SetParameterProperties</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/// Kick off the render process</span>
    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_StartRenderAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><em>_StartRenderAsync</em> is the internal method that runs the render process.  <em>ResetAsync</em> runs the same code block so we build a separate method.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">private</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">_StartRenderAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/// sets Loading</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>Loading <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">/// Queue a Render to show any loading spinners</span>
    <span class="token keyword">await</span> <span class="token function">InvokeAsync</span><span class="token punctuation">(</span>Render<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/// call the public (normally overridden) OnRenderAsync</span>
    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">OnRenderAsync</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_firstRender<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/// first render complete</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_firstRender <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">/// Queue a Render</span>
    <span class="token keyword">await</span> <span class="token function">InvokeAsync</span><span class="token punctuation">(</span>Render<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><em>OnRenderAsync</em> is a prototype - it's normally overridden.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name">Task</span> <span class="token function">OnRenderAsync</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">bool</span></span> firstRender<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Task<span class="token punctuation">.</span>CompletedTask<span class="token punctuation">;</span>
</code></pre></div><p><em>Render</em> contains the same code as <em>StateHasChanged</em> in <em>ComponentBose</em>.  <em>Render</em> does what it says on the tin, places the component's render fragment on the Renderer's render queue.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">protected</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">/// check if we already have a render queued - if so stop, any changes will be captured by the queued render</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_hasPendingQueuedRender<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">/// check if we've never rendered or should render (ShouldRender unless overridden returns true)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_hasNeverRendered <span class="token operator">||</span> <span class="token function">ShouldRender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        _hasPendingQueuedRender <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">/// Queues the component render fragment on the Renderer's render queue.</span>
        <span class="token keyword">try</span>
        <span class="token punctuation">{</span>
            _renderHandle<span class="token punctuation">.</span><span class="token function">Render</span><span class="token punctuation">(</span>_renderFragment<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span>
        <span class="token punctuation">{</span>
            _hasPendingQueuedRender <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/// can be overridden for external control of rendering</span>
<span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">bool</span></span> <span class="token function">ShouldRender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><p><em>ResetAsync</em> resets the component to new and runs a complete re-render.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">ResetAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_firstRender <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_StartRenderAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><em>BuildRenderTree</em> is a prototype.  It's overridden either directly in derived classes with code or the Razor compiler builds it from the Razor markup during the build process.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">BuildRenderTree</span><span class="token punctuation">(</span><span class="token class-name">RenderTreeBuilder</span> builder<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p><em>Attach</em> implements <em>IComponent.Attach</em>. It captures the <em>RenderHandle</em> for the renderer and sets <em>_firstRender</em>.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token comment">/// IComponent Attach implementation</span>
<span class="token return-type class-name"><span class="token keyword">void</span></span> IComponent<span class="token punctuation">.</span><span class="token function">Attach</span><span class="token punctuation">(</span><span class="token class-name">RenderHandle</span> renderHandle<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_renderHandle<span class="token punctuation">.</span>IsInitialized<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">InvalidOperationException</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;The render handle is already set. Cannot initialize a </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp"><span class="token keyword">nameof</span><span class="token punctuation">(</span>ComponentBase<span class="token punctuation">)</span></span><span class="token punctuation">}</span></span><span class="token string"> more than once.&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    _firstRender <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    _renderHandle <span class="token operator">=</span> renderHandle<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>The two <em>InvokeAsync</em> methods provide thread safe methods for running functions or actions on the renderer's synchronisation thread through the RenderHandle's Dispatcher.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token comment">/// Executes the supplied work item on the associated renderer's synchronization context.</span>
<span class="token keyword">protected</span> <span class="token return-type class-name">Task</span> <span class="token function">InvokeAsync</span><span class="token punctuation">(</span><span class="token class-name">Action</span> workItem<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> _renderHandle<span class="token punctuation">.</span>Dispatcher<span class="token punctuation">.</span><span class="token function">InvokeAsync</span><span class="token punctuation">(</span>workItem<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/// Executes the supplied work item on the associated renderer's synchronization context.</span>
<span class="token keyword">protected</span> <span class="token return-type class-name">Task</span> <span class="token function">InvokeAsync</span><span class="token punctuation">(</span><span class="token class-name">Func<span class="token punctuation">&lt;</span>Task<span class="token punctuation">&gt;</span></span> workItem<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> _renderHandle<span class="token punctuation">.</span>Dispatcher<span class="token punctuation">.</span><span class="token function">InvokeAsync</span><span class="token punctuation">(</span>workItem<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>In general, call <em>Render</em> like this to make sure it's run on the correct thread:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token function">InvokeAsync</span><span class="token punctuation">(</span>Render<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// or</span>
<span class="token keyword">await</span> <span class="token function">InvokeAsync</span><span class="token punctuation">(</span>Render<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// rather than </span>
<span class="token function">Render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// or just call</span>

<span class="token keyword">await</span> <span class="token function">RenderAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/// Runs Render on the UI Thread</span>
<span class="token keyword">protected</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">RenderAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">InvokeAsync</span><span class="token punctuation">(</span>Render<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>The final methods are straight from <em>ComponentBase</em> and implement the <em>IHandleEvent</em> and <em>IHandleAfterRender</em> interfaces.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token comment">/// Internal method to track the render event</span>
<span class="token return-type class-name">Task</span> IHandleEvent<span class="token punctuation">.</span><span class="token function">HandleEventAsync</span><span class="token punctuation">(</span><span class="token class-name">EventCallbackWorkItem</span> callback<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">object</span></span> arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">var</span></span> task <span class="token operator">=</span> callback<span class="token punctuation">.</span><span class="token function">InvokeAsync</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name"><span class="token keyword">var</span></span> shouldAwaitTask <span class="token operator">=</span> task<span class="token punctuation">.</span>Status <span class="token operator">!=</span> TaskStatus<span class="token punctuation">.</span>RanToCompletion <span class="token operator">&amp;&amp;</span> task<span class="token punctuation">.</span>Status <span class="token operator">!=</span> TaskStatus<span class="token punctuation">.</span>Canceled<span class="token punctuation">;</span>
    <span class="token function">InvokeAsync</span><span class="token punctuation">(</span>Render<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token return-type class-name">shouldAwaitTask <span class="token punctuation">?</span></span> <span class="token function">CallRenderOnAsyncCompletion</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token punctuation">:</span> Task<span class="token punctuation">.</span>CompletedTask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/// Internal Method triggered after the component has rendered calling OnAfterRenderAsync</span>
<span class="token return-type class-name">Task</span> IHandleAfterRender<span class="token punctuation">.</span><span class="token function">OnAfterRenderAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">var</span></span> firstRender <span class="token operator">=</span> <span class="token operator">!</span>_hasCalledOnAfterRender<span class="token punctuation">;</span>
    _hasCalledOnAfterRender <span class="token operator">|=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">OnAfterRenderAsync</span><span class="token punctuation">(</span>firstRender<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/// Internal method to handle render completion</span>
<span class="token keyword">private</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">CallRenderOnAsyncCompletion</span><span class="token punctuation">(</span><span class="token class-name">Task</span> task<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">await</span> task<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span> <span class="token comment">// avoiding exception filters for AOT runtime support</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Ignore exceptions from task cancellations, but don't bother issuing a state change.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">.</span>IsCanceled<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">throw</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">await</span> <span class="token function">InvokeAsync</span><span class="token punctuation">(</span>Render<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="using-the-component"><a href="#using-the-component" class="header-anchor">#</a> Using the Component</h1> <p>You need to declare inheritance in the Razor file - by default Razor uses <em>ComponentBase</em>.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code>@inherits Component
</code></pre></div><p>The basic pattern you need to follow for <em>OnRenderAsync</em> and <em>OnAfterRenderAsync</em> is shown below.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token comment">// Depending on whether your running any async functions declare as async</span>
<span class="token keyword">protected</span> <span class="token keyword">async</span> <span class="token keyword">override</span> <span class="token return-type class-name">Task</span> <span class="token function">OnRenderAsync</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">bool</span></span> firstRender<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Do anything you need to do before you call down the inheritance tree</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstRender<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// Do anything you need to do only on the first render</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Do anything you need to do on any subsequent render (but not the first)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Do anything you need to do on any render</span>
    
    <span class="token keyword">await</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnRenderAsync</span><span class="token punctuation">(</span>firstRender<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// Do anything you need to do after you've called down the inheritance tree</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstRender<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// Do anything you need to do only on the first render</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Do anything you need to do on any subsequent render (but not the first)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Do anything you need to do on any render</span>

    <span class="token comment">// Return completed task if you haven't declared the method as async</span>
    <span class="token comment">//return Task.CompletedTask;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Be careful about calling <em>Render</em>.  It's very easy to &quot;over&quot; render.  Check in debug mode with a breakpoint on Render and see how often it's called.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token function">InvokeAsync</span><span class="token punctuation">(</span>Render<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// or</span>
<span class="token keyword">await</span> <span class="token function">InvokeAsync</span><span class="token punctuation">(</span>Render<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="code-repository-and-example-sites"><a href="#code-repository-and-example-sites" class="header-anchor">#</a> Code Repository and Example Sites</h2> <p>You can see the component in action in the standard Blazor Weather Application at these sites:</p> <p><a href="https://cec-blazor-wasm.azurewebsites.net/" target="_blank" rel="noopener noreferrer">WASM Weather Version<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://cec-blazor-server.azurewebsites.net/" target="_blank" rel="noopener noreferrer">Blazor Server Version<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>There's a GitHub repository <a href="https://github.com/ShaunCurtis/CEC.Blazor/tree/Experimental" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.  Note you need to be on the Experimental Branch.  <em>Component</em> is in CEC.Blazor/Components/Base.</p> <p><a href="https://www.codeproject.com/Articles/5277618/A-Dive-into-Blazor-Components" target="_blank" rel="noopener noreferrer">There's an earlier article here on Code Project about Components.<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="wrap-up"><a href="#wrap-up" class="header-anchor">#</a> Wrap Up</h2> <p>My decision to dump <em>ComponentBase</em> wasn't taken lightly.  Don't get me wrong, I love Blazor, but I don't think Blazor has got SPA development right in the current iteration.  Nine months in and I have live Blazor commercial applications running on Azure.  I'm a &quot;grey&quot; part time developer with a little more time than most to think a bit more outside-the-box.  Most out-of-the-box SPA development strikes me as too constrained by the Web paradigm.  More articles to come on a developing a little more radically with Blazor - throwing away the router is next!</p> <p>Hopefully this article shows you there's life outside <em>ComponentBase</em>.  If you're relatively new to Blazor this article should give you a good eye-opener into components and how they work.  If you agree with me, use my <em>Component</em> code in any way, shape or form - no permission required.  If you disagree, no problem, I accept and understand - diversity is the spice of life!</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.de94086e.js" defer></script><script src="/assets/js/2.0005fb99.js" defer></script><script src="/assets/js/22.8c84fb58.js" defer></script>
  </body>
</html>
